use alloy_primitives::{Address, Bytes, TxKind, U256};
use alloy_provider::{Provider, ProviderBuilder};
use alloy_rpc_types::eth::{TransactionInput, TransactionRequest};
use alloy_signer::k256::ecdsa::SigningKey;
use alloy_signer_local::PrivateKeySigner;
use alloy_sol_types::{SolCall, SolEvent, SolType, SolValue};
use clap::Parser;
use std::str::FromStr;

use crate::{
    command::Executable,
    contract::{
        status_from_u8, Staking, ValidatorManagement, ValidatorRecord, ValidatorStatus,
        STAKING_ADDRESS, VALIDATOR_MANAGER_ADDRESS,
    },
    util::format_ether,
};

#[derive(Debug, Parser)]
pub struct JoinCommand {
    /// RPC URL for gravity node
    #[clap(long)]
    pub rpc_url: String,

    /// Private key for signing transactions (hex string with or without 0x prefix)
    #[clap(long)]
    pub private_key: String,

    /// Gas limit for the transaction
    #[clap(long, default_value = "2000000")]
    pub gas_limit: u64,

    /// Gas price in wei
    #[clap(long, default_value = "20")]
    pub gas_price: u128,

    /// StakePool address to use for validator registration
    #[clap(long)]
    pub stake_pool: String,

    /// Moniker (display name, max 31 bytes)
    #[clap(long, default_value = "Gravity1")]
    pub moniker: String,

    /// Consensus public key (BLS key)
    #[clap(long)]
    pub consensus_public_key: String,

    /// Proof of possession for the BLS consensus key (192 hex characters, 96 bytes).
    /// This is a BLS signature over the public key, proving ownership of the private key.
    /// It can be found in the `consensus_pop` field of the identity.yaml
    /// file generated by `gravity_cli genesis generate-key`.
    #[clap(long)]
    pub consensus_pop: String,

    /// Network public key (64 hex characters)
    #[clap(long)]
    pub network_public_key: String,

    /// Validator network address in /ip4/{host}/tcp/{port} format
    #[clap(long)]
    pub validator_network_address: String,

    /// Fullnode network address in /ip4/{host}/tcp/{port} format
    #[clap(long)]
    pub fullnode_network_address: String,
}

impl Executable for JoinCommand {
    fn execute(self) -> Result<(), anyhow::Error> {
        let rt = tokio::runtime::Runtime::new()?;
        rt.block_on(self.execute_async())
    }
}

impl JoinCommand {
    async fn execute_async(self) -> Result<(), anyhow::Error> {
        // 1. Initialize Provider and Wallet
        println!("1. Initializing connection...");

        println!("   RPC URL: {}", self.rpc_url);
        let private_key_str = self.private_key.strip_prefix("0x").unwrap_or(&self.private_key);
        let private_key_bytes = hex::decode(private_key_str)?;
        let private_key = SigningKey::from_slice(private_key_bytes.as_slice())
            .map_err(|e| anyhow::anyhow!("Invalid private key: {e}"))?;
        let signer = PrivateKeySigner::from(private_key);
        let wallet_address = signer.address();
        println!("   Wallet address: {wallet_address:?}");

        println!("   ValidatorManagement: {VALIDATOR_MANAGER_ADDRESS:?}");
        println!("   Staking: {STAKING_ADDRESS:?}");

        // Create provider
        let provider = ProviderBuilder::new().wallet(signer).connect_http(self.rpc_url.parse()?);

        let chain_id = provider.get_chain_id().await?;
        println!("   Chain ID: {chain_id}");
        let balance = provider.get_balance(wallet_address).await?;
        println!("   Wallet balance: {} ETH\n", format_ether(balance));

        // 2. Validate existing StakePool
        let stake_pool = Address::from_str(&self.stake_pool)?;
        println!("2. Validating StakePool: {stake_pool:?}");

        // Verify it's a valid pool
        let call = Staking::isPoolCall { pool: stake_pool };
        let input: Bytes = call.abi_encode().into();
        let result = provider
            .call(TransactionRequest {
                from: Some(wallet_address),
                to: Some(TxKind::Call(STAKING_ADDRESS)),
                input: TransactionInput::new(input),
                ..Default::default()
            })
            .await?;
        let is_pool = bool::abi_decode(&result)
            .map_err(|e| anyhow::anyhow!("Failed to decode isPool result: {e}"))?;
        if !is_pool {
            return Err(anyhow::anyhow!("Address is not a valid StakePool"));
        }

        // Check voting power
        let call = Staking::getPoolVotingPowerNowCall { pool: stake_pool };
        let input: Bytes = call.abi_encode().into();
        let result = provider
            .call(TransactionRequest {
                from: Some(wallet_address),
                to: Some(TxKind::Call(STAKING_ADDRESS)),
                input: TransactionInput::new(input),
                ..Default::default()
            })
            .await?;
        let voting_power = U256::abi_decode(&result)
            .map_err(|e| anyhow::anyhow!("Failed to decode voting power: {e}"))?;
        println!("   Current voting power: {} ETH\n", format_ether(voting_power));

        // 3. Check if already registered as validator
        println!("3. Checking if already registered as validator...");
        let call = ValidatorManagement::isValidatorCall { stakePool: stake_pool };
        let input: Bytes = call.abi_encode().into();
        let result = provider
            .call(TransactionRequest {
                from: Some(wallet_address),
                to: Some(TxKind::Call(VALIDATOR_MANAGER_ADDRESS)),
                input: TransactionInput::new(input),
                ..Default::default()
            })
            .await?;
        let is_validator = bool::abi_decode(&result)
            .map_err(|e| anyhow::anyhow!("Failed to decode isValidator result: {e}"))?;
        println!("   Is registered: {is_validator}");

        if is_validator {
            println!("   Validator is already registered, skipping registration step\n");
        } else {
            // 4. Register validator
            println!("4. Registering validator...");

            // Validate moniker length (must not exceed 31 bytes, matching on-chain
            // MAX_MONIKER_LENGTH)
            if self.moniker.len() > 31 {
                return Err(anyhow::anyhow!(
                    "Moniker too long: max 31 bytes, got {} bytes",
                    self.moniker.len()
                ));
            }

            // Validate consensus public key format: must be exactly 96 hex characters (48 bytes BLS
            // key)
            let consensus_pk =
                self.consensus_public_key.strip_prefix("0x").unwrap_or(&self.consensus_public_key);
            if consensus_pk.len() != 96 {
                return Err(anyhow::anyhow!(
                    "Invalid consensus public key: expected 96 hex characters (48 bytes), got {} characters",
                    consensus_pk.len()
                ));
            }
            if !consensus_pk.chars().all(|c| c.is_ascii_hexdigit()) {
                return Err(anyhow::anyhow!(
                    "Invalid consensus public key: contains non-hexadecimal characters"
                ));
            }

            // Validate network public key: must be exactly 64 hex characters (32 bytes)
            let network_pk =
                self.network_public_key.strip_prefix("0x").unwrap_or(&self.network_public_key);
            if network_pk.len() != 64 {
                return Err(anyhow::anyhow!(
                    "Invalid network public key: expected 64 hex characters (32 bytes), got {} characters",
                    network_pk.len()
                ));
            }
            if !network_pk.chars().all(|c| c.is_ascii_hexdigit()) {
                return Err(anyhow::anyhow!(
                    "Invalid network public key: contains non-hexadecimal characters"
                ));
            }

            // Validate consensus proof of possession: must be exactly 192 hex characters (96 bytes)
            let consensus_pop =
                self.consensus_pop.strip_prefix("0x").unwrap_or(&self.consensus_pop);
            if consensus_pop.len() != 192 {
                return Err(anyhow::anyhow!(
                    "Invalid consensus proof of possession: expected 192 hex characters (96 bytes), got {} characters",
                    consensus_pop.len()
                ));
            }
            if !consensus_pop.chars().all(|c| c.is_ascii_hexdigit()) {
                return Err(anyhow::anyhow!(
                    "Invalid consensus proof of possession: contains non-hexadecimal characters"
                ));
            }

            // Validate address format: /ip4/{host}/tcp/{port}
            fn validate_network_address(addr: &str, label: &str) -> Result<(), anyhow::Error> {
                let parts: Vec<&str> = addr.split('/').collect();
                // Expected: ["", "ip4", "{host}", "tcp", "{port}"]
                if parts.len() != 5 ||
                    !parts[0].is_empty() ||
                    parts[1] != "ip4" ||
                    parts[2].is_empty() ||
                    parts[3] != "tcp" ||
                    parts[4].parse::<u16>().is_err()
                {
                    return Err(anyhow::anyhow!(
                        "Invalid {label} address: expected /ip4/{{host}}/tcp/{{port}} format, got '{addr}'"
                    ));
                }
                Ok(())
            }
            validate_network_address(&self.validator_network_address, "validator network")?;
            validate_network_address(&self.fullnode_network_address, "fullnode network")?;

            // Construct full addresses:
            // /ip4/{host}/tcp/{port}/noise-ik/{network_public_key}/handshake/0
            let validator_full_addr =
                format!("{}/noise-ik/{}/handshake/0", self.validator_network_address, network_pk);
            let fullnode_full_addr =
                format!("{}/noise-ik/{}/handshake/0", self.fullnode_network_address, network_pk);

            println!("   Moniker: \"{}\"", self.moniker);
            println!("   Consensus public key: {consensus_pk} ({} bytes)", consensus_pk.len() / 2);
            println!("   Consensus PoP: {consensus_pop} ({} bytes)", consensus_pop.len() / 2);
            println!("   Network public key: {network_pk}");
            println!("   Validator address: {validator_full_addr}");
            println!("   Fullnode address: {fullnode_full_addr}");

            let call = ValidatorManagement::registerValidatorCall {
                stakePool: stake_pool,
                moniker: self.moniker.clone(),
                consensusPubkey: hex::decode(consensus_pk)?.into(),
                consensusPop: hex::decode(consensus_pop)?.into(),
                networkAddresses: bcs::to_bytes(&validator_full_addr)?.into(),
                fullnodeAddresses: bcs::to_bytes(&fullnode_full_addr)?.into(),
            };
            let input: Bytes = call.abi_encode().into();
            let pending_tx = provider
                .send_transaction(TransactionRequest {
                    from: Some(wallet_address),
                    to: Some(TxKind::Call(VALIDATOR_MANAGER_ADDRESS)),
                    input: TransactionInput::new(input),
                    gas: Some(self.gas_limit),
                    gas_price: Some(self.gas_price),
                    ..Default::default()
                })
                .await?;
            let tx_hash = *pending_tx.tx_hash();
            println!("   Transaction hash: {tx_hash}");
            let _ = pending_tx
                .with_required_confirmations(2)
                .with_timeout(Some(std::time::Duration::from_secs(60)))
                .watch()
                .await?;

            let receipt = provider
                .get_transaction_receipt(tx_hash)
                .await?
                .ok_or(anyhow::anyhow!("Failed to get transaction receipt"))?;
            println!(
                "   Transaction confirmed, block number: {}",
                receipt.block_number.ok_or(anyhow::anyhow!("Failed to get block number"))?
            );
            println!("   Gas used: {}", receipt.gas_used);

            // Check registration event
            let mut found = false;
            for log in receipt.logs() {
                if let Ok(event) = ValidatorManagement::ValidatorRegistered::decode_log(&log.inner)
                {
                    println!("   Registration successful!");
                    println!("   - StakePool: {}", event.stakePool);
                    println!("   - Moniker: {}", event.moniker);
                    found = true;
                    break;
                }
            }
            if !found {
                println!("   Registration event not found\n");
                return Err(anyhow::anyhow!("Failed to find ValidatorRegistered event"));
            }
            println!();
        }

        // 5. Check validator information
        println!("5. Checking validator information...");
        let call = ValidatorManagement::getValidatorCall { stakePool: stake_pool };
        let input: Bytes = call.abi_encode().into();
        let result = provider
            .call(TransactionRequest {
                from: Some(wallet_address),
                to: Some(TxKind::Call(VALIDATOR_MANAGER_ADDRESS)),
                input: TransactionInput::new(input),
                ..Default::default()
            })
            .await?;
        let validator_record = <ValidatorRecord as SolType>::abi_decode(&result)
            .map_err(|e| anyhow::anyhow!("Failed to decode validator record: {e}"))?;
        let status = status_from_u8(validator_record.status);
        println!("   Validator information:");
        println!("   - Validator: {}", validator_record.validator);
        println!("   - Moniker: {}", validator_record.moniker);
        println!("   - Status: {status:?}");
        println!("   - Bond: {} ETH", format_ether(validator_record.bond));
        println!("   - Fee recipient: {}", validator_record.feeRecipient);
        println!("   - StakePool: {}", validator_record.stakingPool);
        println!(
            "   - Network addresses: {}",
            bcs::from_bytes::<String>(&validator_record.networkAddresses)
                .unwrap_or_else(|_| hex::encode(&validator_record.networkAddresses))
        );
        println!(
            "   - Fullnode addresses: {}",
            bcs::from_bytes::<String>(&validator_record.fullnodeAddresses)
                .unwrap_or_else(|_| hex::encode(&validator_record.fullnodeAddresses))
        );

        if !matches!(status, ValidatorStatus::INACTIVE) {
            println!("   Validator status is not INACTIVE, skipping join step\n");
            return Ok(());
        }
        println!();

        // 6. Join validator set
        println!("6. Joining validator set...");
        let call = ValidatorManagement::joinValidatorSetCall { stakePool: stake_pool };
        let input: Bytes = call.abi_encode().into();
        let pending_tx = provider
            .send_transaction(TransactionRequest {
                from: Some(wallet_address),
                to: Some(TxKind::Call(VALIDATOR_MANAGER_ADDRESS)),
                input: TransactionInput::new(input),
                gas: Some(self.gas_limit),
                gas_price: Some(self.gas_price),
                ..Default::default()
            })
            .await?;
        let tx_hash = *pending_tx.tx_hash();
        println!("   Transaction hash: {tx_hash}");
        let _ = pending_tx
            .with_required_confirmations(2)
            .with_timeout(Some(std::time::Duration::from_secs(60)))
            .watch()
            .await?;

        let receipt = provider
            .get_transaction_receipt(tx_hash)
            .await?
            .ok_or(anyhow::anyhow!("Failed to get transaction receipt"))?;
        println!(
            "   Transaction confirmed, block number: {}",
            receipt.block_number.ok_or(anyhow::anyhow!("Failed to get block number"))?
        );
        println!("   Gas used: {}", receipt.gas_used);
        println!(
            "   Transaction cost: {} ETH",
            format_ether(U256::from(receipt.effective_gas_price) * U256::from(receipt.gas_used))
        );

        // Check join event
        let mut found = false;
        for log in receipt.logs() {
            if let Ok(event) = ValidatorManagement::ValidatorJoinRequested::decode_log(&log.inner) {
                println!("   Join request successful!");
                println!("   - StakePool: {}", event.stakePool);
                found = true;
                break;
            }
        }
        if !found {
            println!("   Join event not found\n");
            return Err(anyhow::anyhow!("Failed to find ValidatorJoinRequested event"));
        }
        println!();

        // 7. Final status check
        println!("7. Final status check...");
        let call = ValidatorManagement::getValidatorStatusCall { stakePool: stake_pool };
        let input: Bytes = call.abi_encode().into();
        let result = provider
            .call(TransactionRequest {
                from: Some(wallet_address),
                to: Some(TxKind::Call(VALIDATOR_MANAGER_ADDRESS)),
                input: TransactionInput::new(input),
                ..Default::default()
            })
            .await?;
        let status_u8 = result.last().copied().unwrap_or(0);
        let validator_status = status_from_u8(status_u8);
        match validator_status {
            ValidatorStatus::PENDING_ACTIVE => {
                println!("   Validator status is PENDING_ACTIVE");
                println!("   Please wait for the next epoch to automatically become ACTIVE\n");
            }
            ValidatorStatus::ACTIVE => {
                println!("   Validator status is ACTIVE");
                println!("   Successfully joined the validator set\n");
            }
            _ => {
                println!("   Validator status is {validator_status:?}, unexpected status\n");
                return Err(anyhow::anyhow!("Unexpected validator status: {validator_status:?}"));
            }
        }
        Ok(())
    }
}
