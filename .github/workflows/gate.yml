name: CI Gate

# Reusable workflow: approval gate + duplicate-run check + changed-files filter
on:
  workflow_call:
    inputs:
      workflow_file:
        description: 'Workflow filename for duplicate-run detection (e.g. rust-ci.yml)'
        required: true
        type: string
      ignore_patterns:
        description: >
          Pipe-separated glob patterns to ignore when checking changed files.
          Example: 'book/*|scripts/*|*.md'
        required: true
        type: string
    outputs:
      should_run:
        description: 'Whether downstream jobs should run'
        value: ${{ jobs.gate.outputs.should_run }}

jobs:
  gate:
    name: Gate
    runs-on: ubuntu-latest
    # The approval / branch filter is applied by the CALLER's top-level `if`
    # or trigger events, so no extra `if` is needed here.
    outputs:
      should_run: ${{ steps.final.outputs.should_run }}
    steps:
      # ── 1. Duplicate-run check ──────────────────────────────────────────
      - name: Check for duplicate runs
        id: dup
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Use PR branch instead of head_sha so that the check is PR-wide,
          # not commit-specific.  Once CI passes on any commit in the PR,
          # subsequent approvals (even after new pushes) will be skipped.
          # The author can always re-run manually if needed.
          PR_BRANCH="${{ github.event.pull_request.head.ref }}"

          # Check for in-progress runs on this PR (any commit)
          IN_PROGRESS=$(gh api \
            "repos/${{ github.repository }}/actions/workflows/${{ inputs.workflow_file }}/runs?branch=${PR_BRANCH}" \
            --jq "[.workflow_runs[] | select(.id != ${{ github.run_id }} and .status == \"in_progress\")] | length")
          if [ "$IN_PROGRESS" -gt "0" ]; then
            echo "CI already in progress for branch ${PR_BRANCH}. Skipping."
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for successful runs on this PR (any commit) — but only
          # count runs where real test jobs actually ran (not just gate +
          # skipped downstream jobs)
          SUCCESSFUL_RUN_IDS=$(gh api \
            "repos/${{ github.repository }}/actions/workflows/${{ inputs.workflow_file }}/runs?branch=${PR_BRANCH}" \
            --jq "[.workflow_runs[] | select(.id != ${{ github.run_id }} and .conclusion == \"success\")] | .[].id")

          HAS_REAL_SUCCESS=false
          for RUN_ID in $SUCCESSFUL_RUN_IDS; do
            # Count jobs that actually completed (not skipped), excluding gate jobs
            REAL_JOBS=$(gh api \
              "repos/${{ github.repository }}/actions/runs/$RUN_ID/jobs" \
              --jq '[.jobs[] | select(.conclusion == "success" and (.name | test("(?i)gate") | not))] | length')
            if [ "$REAL_JOBS" -gt "0" ]; then
              echo "Found previous run #$RUN_ID with real test execution on branch ${PR_BRANCH}."
              HAS_REAL_SUCCESS=true
              break
            fi
          done

          if [ "$HAS_REAL_SUCCESS" = "true" ]; then
            echo "CI already passed for branch ${PR_BRANCH}. Skipping."
            echo "should_run=false" >> $GITHUB_OUTPUT
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
          fi

      # ── 2. Changed-files relevance check ───────────────────────────────
      - name: Check changed files
        id: files
        if: steps.dup.outputs.should_run == 'true' && github.event_name == 'pull_request_review'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CHANGED_FILES=$(gh api \
            "repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files?per_page=100" \
            --paginate --jq '.[].filename')

          IGNORE_PATTERNS="${{ inputs.ignore_patterns }}"

          # Split pipe-separated patterns into an array
          IFS='|' read -ra PATTERNS <<< "$IGNORE_PATTERNS"

          HAS_RELEVANT_CHANGES=false
          while IFS= read -r file; do
            IGNORED=false
            for pattern in "${PATTERNS[@]}"; do
              # If pattern ends with /*, match the directory prefix to handle
              # nested files (e.g. bin/sentinel/* should match bin/sentinel/src/main.rs)
              if [[ "$pattern" == *'/*' ]]; then
                prefix="${pattern%/*}/"
                if [[ "$file" == "$prefix"* ]]; then
                  IGNORED=true
                  break
                fi
              elif [[ "$file" == $pattern ]]; then
                IGNORED=true
                break
              fi
            done
            if [ "$IGNORED" = "true" ]; then
              echo "  [IGNORED] ${file}"
            else
              echo "  [RELEVANT] ${file}"
              HAS_RELEVANT_CHANGES=true
            fi
          done <<< "${CHANGED_FILES}"

          if [ "${HAS_RELEVANT_CHANGES}" = "false" ]; then
            echo "All changes are in ignored paths. Skipping."
            echo "has_relevant=false" >> $GITHUB_OUTPUT
          else
            echo "✓ Found relevant code changes."
            echo "has_relevant=true" >> $GITHUB_OUTPUT
          fi

      # ── 3. Final decision ──────────────────────────────────────────────
      - name: Determine final result
        id: final
        run: |
          DUP_RESULT="${{ steps.dup.outputs.should_run }}"
          FILE_RESULT="${{ steps.files.outputs.has_relevant }}"

          # If dup check already said no, skip
          if [ "$DUP_RESULT" != "true" ]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # If files check ran and said no relevant changes, skip
          if [ "$FILE_RESULT" = "false" ]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "should_run=true" >> $GITHUB_OUTPUT
